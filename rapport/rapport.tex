\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[francais]{babel}
\usepackage{listings}
\usepackage{comment}


\title{Rapport du projet de compilation}
\date{10/04/2017}
\author{Demoulins Louis \and Gagnon Antoine \and Massamiri Michel \and Nobé Cyril}

\begin{document}

\maketitle
\newpage

\tableofcontents

\newpage
\section{Introduction}

Le présent projet de compilation a été effectué dans le cadre de l'Unité d'Enseignement "Compilation" de la troisième année de licence Informatique de l'université de Bordeaux.

\medbreak

Le but de ce projet est de créer un interpréteur d'un langage similaire au langage Pascal. Il s'agit cependant d'une version simplifiée de ce langage qui se nomme Pseudo-Pascal.
En effet il ne comportes que deux types de variables, les entiers et les booléens, et des tableaux dynamiques de ces deux types.

Dans un second temps nous avons du créer un interpréteur d'un langage à trois adresses, qui sert de langage intermédiaire entre le Pseudo-Pascal et le langage assembleur de la machine.

Enfin il était demande de créer un compilateur (traducteur) du langage Pseudo-Pascal vers le code à trois adresses.
\bigbreak
L'organisation du rapport est symétrique : dans une première partie sur un langage, nous discuterons de l'interpréteur, en décrivant au préalable ce qui nous a été donné pour faire ce travail.
Ensuite nous verrons comment nous avons écrit l'interpréteur, en essayant de détaillé un maximum ce qui est utile de détaillé.

Enfin, nous verrons comment nous avons fait le compilateur, en nous basant sur ce que nous aurons dit précédemment pour l'interpréteur.

\newpage
\section{Interpreteur Pseudo Pascal}

L'interpréteur du Pseudo-Pascal se compose d'un lexer, d'un parser et d'un analyseur sémantique. A cela nous avons ajouter différentes structures de données pour créer l'interpréteur, comme par exemple un arbre de nodes.

\subsection{Eléments donnés}

Pour ce projet, on nous avait donner un certains nombres d'éléments. Prinsipalement, il nous a été donné la grammaire et la syntaxe du langage pseudo-pascal, ainsi que ces spécificité.

\subsubsection{Structure du code Pseudo-Pascal}

Le langage pseudo pascal contient donc un certain nombre de mots clés et d'opérateurs unaire ou binaire :

\begin{tabular}{|p{2cm}|p{11cm}|}
  \hline
  Opérateur / mot clé PP  & effet de l'opérateur \\
  \hline
  \hline
  defun & L'expression suivant ce mot clé défini une fonction\\ \hline
  defpro & L'expression suivant ce mot clé défini une procédure\\ \hline
  skip & Passe à l'instruction suivante\\ \hline
  true & Renvoie la valeur "true" \\ \hline
  false & Renvoie la valeur "false" \\ \hline
  if & Si l'expression suivant le if est vrai, on effectue le bloc entre le then et le else\\ \hline
  then & Le code suivant le then est a exécuter si la condition après le if est validée\\ \hline
  else & Le code suivant le then est a exécuter si la condition après le if n'est pas validée\\ \hline
  while & Si l'expression suivant le mot clé while vaut true, alors on boucle, sinon on sort de la boucle\\ \hline
  do & Après le mot clé do se trouve le code de la boucle à effectuer\\ \hline
  var & Mot clé permettant de déclarer une variable \\ \hline
  + & Opérateur binaire retournant la somme de la valeur des expressions à sa droite et sa gauche\\ \hline
  - & Opérateur binaire retournant la différence de la valeur des expressions qui sont à sa droite et sa gauche\\ \hline
  * & Opérateur binaire retournant le produit de la valeur des expressions qui sont à sa droite et sa gauche\\ \hline
  and & Opérateur binaire retournant le résultat de l'opération logique ET de la valeur des expressions qui sont à sa droite et sa gauche\\ \hline
  or & Opérateur binaire retournant le résultat de l'opération logique OU de la valeur des expressions qui sont dà sa droite et sa gauche\\ \hline
  not & Opérateur unaire retournant le résultat de l'opération logique NON de la valeur de l'expression à sa droite \\ \hline
  < & Opérateur binaire retournant "true" si la valeur de l'expression de gauche est plus petite que celle de droite, "false" sinon\\ \hline
  = & Opérateur binaire retournant "true" si la valeur de l'expression de gauche est égale à celle de droite, "false" sinon\\ \hline
  := & Opérateur affectant à la variable à sa gauche la valeur de l'expression à sa droite \\ \hline
\end{tabular}



\subsection{Eléments programmés}



\newpage
\section{Compilateur Pseudo Pascal}

Pour compiler le code du Pseudo-Pascal vers le Code à 3 adresses\footnote{Pour les informations sur le code à trois adresses (structure, fonctionnement, etc.), voir la section 4.}, nous sommes partit de l'idée suivante : les expressions simples en PP sont facilement traductible vers le C3A :

\begin{lstlisting}
    Var v : integer
    v := 1
\end{lstlisting}

Donne en C3A

\begin{lstlisting}
    ET0 :Afc :1 : :v
\end{lstlisting}

Ou encore, pour une addition :

\begin{lstlisting}
    Var v : integer
    v := 4 + 2
\end{lstlisting}

Donne en C3A

\begin{lstlisting}
    ET0 :Afc :4 : :X1
    ET1 :Afc :2 : :X2
    ET2 :Pl :X1 :X2 :v
\end{lstlisting}

\bigbreak

Une fois ce constat fait, il a juste fallut se dire que les opération compliquées (comme v := (2+7) * 7) peuvent être divisées en des opérations plus simple (v := 2+7; v := v*7).

Ainsi, pour reprendre les exemples entre parentheses, le code :

\begin{lstlisting}
    Var v : integer
    v := (2+7) * 7
\end{lstlisting}

Donne en C3A

\begin{lstlisting}
    ET0 :Afc :2 : :X1
    ET1 :Afc :7 : :X2
    ET2 :Pl :X1 :X2 :v
    ET3 :Afc :7 : :X3
    ET4 :Mu :v :X3 :v
\end{lstlisting}

Il est à noter que nous affectons deux fois la variables 7 à des variables temporaires dans cette traduction. Il est donc possible d'optimiser la compilation, en ne réaffectant pas la valeur 7 à une variable mais en utilisant directement X2, mais par manque de temps et d'expérience, nous n'y sommes pas parvenus.
\bigbreak

\newpage
\section{Interpreteur Code à 3 Adresses}

L'interpréteur du code à trois adresses se compose principalement d'un lexer. Etant donné que le code à trois adresses ne possède pas de grammaire au même titre que le langage Pseudo-Pascal,
dû au fait qu'on ne puisse exécuter qu'une seule action élémentaire par ligne de code (il est impossible d'avoir une expression (X + Y)*2 sur une même ligne), il ne nécissite donc pas l'implémentation d'un parser associé.

A ce lexer vient s'ajouter des fichiers complémentaires. Le fichier environ.c permet de créer les environnements dans lesquels vont être exécuter les différentes instruction qu'on aura au préalable écrite. Ce sont ces environnement qui vont donner les valeurs des variables en fin d'exécution.
On utilise aussi le fichier bilquad.c permettant de créer des bi-listes de quadruplets.

Les environnements, quadruplets et bi-listes de quadruplets seront définits plus loins. Nous allons commencer par voir la structure du code à trois adresses.


\subsection{Eléments donnés}
Nous allons d'abord passer en revue les éléments qui nous ont été donnés pour pouvoir faire ce projet. Ces éléments sont les bi-listes de quadruplets, les quadruplets, les environnements et la structure du code.
\subsubsection{Structure du code à trois adresses}

Le code à trois adresses se compose de cinq éléments :
\begin{itemize}
\item Une étiquette
\item Un opérateur
\item Un premier argument
\item Un second argument
\item La destination de l'operation
\end{itemize}

Il est à noter que tous les éléments ne sont pas toujours nécessaires pour toutes les opérations possibles.
\medbreak
L'étiquette désigne grossièrement l'emplacement de l'instruction dans le programme. Elle permettent de pouvoir revenir à une instruction déjà effectuée (dans le cas d'une boucle) ou d'en sauter un certain certaines (apres une condition par exemple). Il a la forme ETx, où x désigne un nombre (par exemple ET12).

Les arguments et la déstination pointe soit sur des variables, soit sur des étiquettes, soit des numéraux. Pour une addition par exemple, on ajoutera la valeur de la variable du premier et du second argument, et on stockera le résultat dans la destination.

L'opérateur indique quelle opération va être effectué. Les différents opérateurs sont (dans le tableau, code à trois adresses est désigné par l'acronyme C3A):

\begin{tabular}{|p{1.5cm}|p{2cm}|p{7cm}|}
  \hline
  Opérateur C3A & nom opérateur complet 2 & effet de l'opérateur \\
  \hline
  \hline
  Pl & Plus & Affecte à la destination la somme des deux arguments \\  \hline
  Mo & Moins & Affecte à la destination la différence du premier et du second arguments \\  \hline
  Mu & Multiplication & Affecte à la destination le produit des deux arguments \\  \hline
  And & And & Affecte à la destination le résultat de l'opération logique ET des deux arguments \\  \hline
  Or & Or & Affecte à la destination le résultat de l'opération logique OU des deux arguments \\  \hline
  Not & Not & Affecte à la destination le résultat de l'opération logique NON sur le premier argument \\  \hline
  Lt & Lower Than & Affecte à la destination 0 si le premier argument est plus petit que le second, 1 sinon\\  \hline
  Af & Affecte & Affecte au second argument la valeur du premier, qui est une variable\\  \hline
  Afc & Affecte & Affecte au second argument la valeur du premier, qui est un numéral\\  \hline
  AfInd & Affecte à l'indice & Affecte à Arg1[Arg2] la valeur de destination\\  \hline
  Ind & Indice & Affecte à la destination la valeur de Arg1[Arg2]\\  \hline
  Jp & Jump & Fait un saut à l'instruction dont l'etiquette est destination\\  \hline
  Jz & Jump if Zero & Fait un saut à l'instruction dont l'etiquette est destination si la valeur du premier argument vaut 0\\  \hline
  Call & Call & Appelle la fonction se trouvant à l'étiquette destination\\  \hline
  Ret & Return & Retourne à l'instruction suivant le dernier call effectué\\  \hline
  Param & Paramettre & Ajoute un paramettre pour le prochain appel de fonction, ayant comme nom le premier argument et comme valeur celle du second\\  \hline
  Sk & Skip & Ne modifie pas l'environnement, passe directement à l'instruction suivante\\  \hline
  St & Stop & Termine l'exécution du programme\\  \hline
\end{tabular}

\newpage

Ainsi, avec tous ces opérateurs, un programme permettant de calculer 4 + 5 serait :
\begin{lstlisting}
    ET0 :Afc :4 : :X1
    ET1 :Afc :5 : :X2
    ET2 :Pl :X1 :X2 :X3
    ET3 :St : : :
\end{lstlisting}

Dans le but d'illustrer l'utilisation des fonctions, voici un bout de code permettant de calculer PARAM1 modulo PARAM2, et de donner le résultat dans RESULT.

\begin{lstlisting}
    ET0 :Af :PARAM1 : :X1
    ET1 :Lt :PARAM1 :PARAM2 :X0
    ET2 :Jz :X0 : :ET7
    ET3 :Sk : : :
    ET4 :Mo :X1 :PARAM2 :X1
    ET5 :Lt :PARAM2 :X1 :X0
    ET6 :Jz :X0 : :ET3
    ET7 :Af :X1 : :RETURN
    ET8 :Ret : : :

    ET9 :Afc :30 : :PARAM1
    ET10 :Afc :5 : :PARAM2
    ET11 :Afc :0 : :RETURN
    ET12 :Param :PARAM1 :PARAM1 :
    ET13 :Param :PARAM2 :PARAM2 :
    ET14 :Call : : :ET0
    ET15 :Sk : : :
    ET16 :St : : :
\end{lstlisting}

\subsubsection{Quadruplets et Bi-listes de quadruplets}

Ces quadruplets servent à stocker les différentes instructions du programme en code à trois adresses. Un quadruplet est définit comme :

\begin{itemize}
\item Une étiquette (char * ETIQ)
\item Un opérateur (int OP)
\item Un triplet de noms, permettant de définir les deux arguments et la destination e l'opération (char * ARG1, * ARG2, * RES)
\item Le quadruplet suivant (struct cellquad SUIV)
\end{itemize}

Les étiquettes correspondes aux étiquettes données dans le code à trois adresses. Elles sont donc de la forme ETn où n est un nombre.

Les opérateurs sont définit dans un fichier à part. Ce sont des entiers positifs dont la valeur est comprise entre 257 et 310.

Le triplet de noms correspond soit aux noms des arguments et du résultat, soit à des numéraux.

Le quadruplet SUIV permet de construire la simple-liste de quadruplets.

\subsubsection{Les environnements}

Les environnements sont ce qui rend l'interpreteur utilisable. Ils permettent de stocker les variables et leur valeur.
En fin d'éxécution de l'interpréteur, on voit s'afficher le résultat de l'éxécution, avec la valeur de chaque variables.

Un environnement est une liste de couples. Une cellule environnement est donc définie par le triplet suivant :

\begin{itemize}
\item Le nom de la variable (char * ID)
\item La valeur de la variable (int VAL)
\item La cellule suivante (ENV *SUIV)
\end{itemize}

\bigbreak
Par exemple, pour le code qui calcul la différence entre 5 et 2 suivant :
\begin{lstlisting}
    ET0 :Afc :2 : :X1
    ET1 :Afc :5 : :X2
    ET3 :Mo :X2 :X1 :X3
    ET4 :St : : :
\end{lstlisting}

On obtient le résultat d'environnement suivant :

\begin{lstlisting}
    variable X3 valeur 3
    variable X2 valeur 5
    variable X1 valeur 2
    fin d' environnement
\end{lstlisting}


\subsection{Eléments programmés}

Nous allons voir dans cette partie, de quelle manières nous avons choisit de programmer les différentes instructions de l'interpréteur.

Il est a noté que pour ce faire, notre lexer, en fin d'exécution, "déroule" la biliste de quadruplet.
\subsubsection{Opérations arithmétiques, logiques et comparatifs}
Nous avons dans un premier temps traité les opération "simple", en commencant par les opérations arithmétiques et logiques.
Pour ce faire nous avons récupérer les valeurs des variables depuit l'environnement, puis nous avons effectué l'opération en question sur ces deux variables et l'avons stocké dans la variable destination.

Voici un exemple pour les oppérations à deux arguments :

\begin{lstlisting}
    if(q->OP == Pl || q->OP == Mu || q->OP == Mo
                   || q->OP == And || q->OP == Or)
    {
        if(rech(q->RES, environnement) == NULL)
            initenv(&environnement, q->RES);
        affect(environnement, q->RES,
                        eval(q->OP, valch(environnement, q->ARG1)
                                  , valch(environnement, q->ARG2)
                            ));
    }
\end{lstlisting}

Ici, dans q->OP se trouve l'opérateur, comme on l'a vu précédemment. Si l'opérateur est un correspond à une opération arithùétique ou logique, on affecte à la variable destination (q->RES) la valeur du résultat de l'opération (qui est effectué dans la fonction eval).
\medbreak
Dans le cas de l'opérateur Not, on cherche juste la valeur de la variable passée en ARG1, puis on effectue l'opération du not en C et stockons le résultat dans la variable destination.
\medbreak
L'operateur Lt (lower than), quand à lui, doit comparer deux valeurs. Il suffit donc de récupérer les valeurs des deux arguments et d'effectuer la comparaison :

\begin{lstlisting}
    if(q->OP == Pl || q->OP == Mu || q->OP == Mo
                   || q->OP == And || q->OP == Or)
    {
        if(rech(q->RES, environnement) == NULL)
            initenv(&environnement, q->RES);
        if(valch(environnement, q->ARG1) < valch(environnement, q->ARG2))
            affect(environnement, q->RES, 1);
        else
            affect(environnement, q->RES, 0);
    }
\end{lstlisting}


\subsubsection{Opération de sauts, de non changement d'environnement et de fin de programme}

Les opération de jump sont programmés de manière a ce que, dans le cas on doit faire un saut, le quadruplet que nous allons lire a la prochaine itération de la boucle, sera non pas le suivant du quadruplet actuel, mais celui dont l'étiquette est désigné par la destinantion.
\medbreak
L'opération skip qui n'a aucun effet sur l'environnement, a tout simplement était laissé vide. On ne fait aucune opération, on se contente juste de passer à l'instruction suivante.
\medbreak
L'opération stop effectue un "return 0" dans le programme C, permettant de dire que le programme s'est terminé de manière normale.

\subsubsection{Opérateurs pour les fonctions}

Pour implémenter les appels de focntions en code à trois adresses, il a été nécessaire de créer une pile d'appel.
Pour ce faire, nous avons céer un tableau d'environnements appelé stack. Stack[0] est l'environnement dans lequel nous n'avons pas encore appelé de fonctions.
Toutes les cases du tableau sont initialiser à NULL pour éviter des problèmes d'erreurs de segmentation.

De plus nous avons ajouter une variable servant de pointeur de pile, pour savoir à quel endroit nous en somme. Ce pointeur s'appelle stackLayer (ce nom est arbitraire).
\bigbreak
L'opérateur param fait en sorte d'ajouter dans le stack[stackLayer + 1] la variable de nom ARG1 et de valeur ARG2. Il a le même fonctionnement qu'un opérateur d'affectation, seulement il ne le fait pas dans le même environnement.
\medbreak
L'opérateur call permet de lancer une fonction débuttant à l'étiquette destination. Pour ce faire il a fallut commencer par vérifier que le stackLayer suivant ne dépasse pas la taille de la pile.
Si c'était le cas, le programme s'arrête en retournant l'erreur "Stack Overflow"

Une fois que cette vérification est faite, il suffit de modifier le QUAD courant vers l'étiquette, de stocker le SUIV du QUAD courant dans une pile de QUAD temporaire (pour y revenir plus tard), et de changer l'environnement courant par l'environnement stack[stackLayer + 1].
\medbreak
L'opérateur ret a l'effet inverse du call. Il commence par vérifier que le stackLayer n'est pas à 0. Si c'était le cas ret aurait le même effet que le stop.

Sinon, le programme repart vers l'état qu'il avait avant le dernier call, en modifiant l'environnement à stack[stackLayer - 1] et en mettant la valeur de la QUAD a celle qui est la plus haute dans la pile temporaire.

\subsubsection{Opérateurs d'affectation}

Les opérateurs d'affectations on tous plus ou moins le même fonctionnenemt. En effet, que ce soit à partir de la valeur d'une variable ou d'un numéral, la seule chose qui change est la fonction qu'on utilise pour récuperer la valeur a affecté (valch() dans le cas d'une valeur de variable et atoi dans le cas d'un numéral).
Cependant, une chose qui est importante de noter est la manière que nous avons utiliser pour traiter les tableaux.
\medbreak
Nous ne savions pas exactement comment traiter le cas de l'affectation depuis ou vers une case d'un tableau.
Pour ce faire, nous avons raisonner de la manière suivante : les tableaux fonctionne comme les variables classiques, ils ont cependant une notation légèrement différente.

Nous avons donc décider d'utiliser le système de notation existant. Pour insérer une valeur dans la variable X1[3], nous avons simpement creer une variable se nommant exactement "X1[3]".
Du fait que les vriables ne peuvent être composées que de lettres et de nombres, il est impossibles pour l'utilisateur d'en créer une ayant cette forme.
Ainsi, quand on utilise l'instruction AfInd, on concatène ARG1, '[', ARG2 et ']' pour créer ladite case du tableau.

Si ARG2 est une variable, alors on utilise la valeur de ARG2, si c'est un numéral, on utilise le numéral tel quel, sinon on renvoit une erreur.
Il ne reste plus qu'a assigner à cette variable la valeur souhaitée, qui se trouve dans la destination.

De la même manière, nous récupérons ARG1[ARG2]


























\begin{comment}

=====================================
-------------------------------------
    COMMENTAIRE
-------------------------------------
=====================================

\newpage
\section{Compilateur Code à 3 Adresses}

L'essentiel du fonctionnement du compilateur du code à trois adresses vers un langage assembleur est identique au fonctionnement de l'interpreteur.
En effet, on lit le code puis on le stock dans une bi-liste de quadruplets. La différence réside au moment de traiter le code précédemment lu.

Ici nous n'allons pas remplir des environnements comme nous l'avons fait précédemment, mais nous allons écrire les différentes instructions dans le langage machine, qui dans ce cas est le Y86.
L'écriture du code Y86 se fait sur la sortie standard, via la fonction C "printf", que nous pouvons rediriger dans le but d'écrire le code directement dans un fichier.

Le fait que l'écriture se fasse sur la sortie standard permet de tester plus simplement le programme sur des petits exemples.


\subsection{Traduction directe et quasi-directe}


Une partie de cette conversion a été assez simple, dû au fait qu'il existe des correspondances dirrecte (ou en 2 instruction, en ajoutant mrmovl dans certains cas) pour certaines instruction :

\begin{center}
    \begin{tabular}{|c|c|}
        \hline
        Code C3A & Code Y86 \\
        \hline
        \hline
        Jp & jmp\\ \hline
        Jz & je\\ \hline
        St & halt\\ \hline
        Sk & nop\\ \hline
        Pl & addl \\ \hline
        Mo & subl \\ \hline
        And & andl \\ \hline
        Or & orl \\ \hline
        Call & call \\ \hline
        Ret & ret \\ \hline
        Param & pushl \\ \hline
    \end{tabular}
\end{center}


Comme nous pouvons le voir, sur les 18 insructions du code à trois adresses, 11 sont traduisible immédiatement ou presque. A celles-ci on peut ajouter le Mu, qui a été donner dans les exemples de code du projet.

\subsection{Traductions longues}
\end{comment}


\end{document}
